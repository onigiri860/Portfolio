<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3D Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; } /* 初期背景を黒に */
    #info {
      position: fixed; top: 10px; left: 10px; color: white;
      background: rgba(0,0,0,0.6); padding: 10px;
      border-radius: 8px; font-family: sans-serif; font-size: 14px; z-index: 10;
      pointer-events: none; /* 文字の上でもクリックが貫通するように */
    }
    #back {
      position: fixed; bottom: 20px; right: 20px;
      padding: 12px 20px; border-radius: 30px; border: none;
      background: #38bdf8; color: #020617; cursor: pointer; z-index: 10;
      font-weight: bold;
    }
    #back:hover { background: #fff; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>

<div id="info">
  画面をクリックで操作開始<br>
  WASD：移動 / マウス：視点<br>
  ESC：操作解除
</div>

<button id="back">Webへ戻る</button>

<script type="module">
  // ★重要：インポートマップを使った書き方に変更
  import * as THREE from 'three';
  import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

  // --- 1. シーンのセットアップ ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // 空の色
  scene.fog = new THREE.Fog(0x87ceeb, 10, 50);  // 遠くを霞ませる

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.6, 5); // 目線の高さ(1.6m)に設定

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // --- 2. ライト ---
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(10, 20, 10);
  scene.add(dirLight);

  // --- 3. オブジェクト ---
  // 床
  const groundGeo = new THREE.PlaneGeometry(100, 100);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  // 建物生成関数
  function createBuilding(x, z, color, label) {
    const height = 6 + Math.random() * 8;
    const geometry = new THREE.BoxGeometry(4, height, 4);
    const material = new THREE.MeshStandardMaterial({ color: color });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(x, height / 2, z);
    scene.add(mesh);
  }

  // 建物を配置
  createBuilding(8, -10, 0x4ade80, "Works");
  createBuilding(-8, -15, 0x60a5fa, "About");
  createBuilding(0, -25, 0xfbbf24, "Skills");

  // --- 4. コントロール (PointerLock) ---
  const controls = new PointerLockControls(camera, document.body);

  // 画面クリックでロック
  document.body.addEventListener('click', () => {
    controls.lock();
  });

  controls.addEventListener('lock', () => {
    document.getElementById('info').style.display = 'none';
  });

  controls.addEventListener('unlock', () => {
    document.getElementById('info').style.display = 'block';
  });

  // 移動用キー管理
  const moveState = { forward: false, backward: false, left: false, right: false };
  
  const onKeyDown = (event) => {
    switch (event.code) {
      case 'KeyW': moveState.forward = true; break;
      case 'KeyA': moveState.left = true; break;
      case 'KeyS': moveState.backward = true; break;
      case 'KeyD': moveState.right = true; break;
    }
  };

  const onKeyUp = (event) => {
    switch (event.code) {
      case 'KeyW': moveState.forward = false; break;
      case 'KeyA': moveState.left = false; break;
      case 'KeyS': moveState.backward = false; break;
      case 'KeyD': moveState.right = false; break;
    }
  };

  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);

  // --- 5. アニメーションループ ---
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    if (controls.isLocked) {
      const delta = clock.getDelta(); // 前フレームからの経過時間
      const speed = 10 * delta;       // 移動速度調整

      if (moveState.forward) controls.moveForward(speed);
      if (moveState.backward) controls.moveForward(-speed);
      if (moveState.right) controls.moveRight(speed);
      if (moveState.left) controls.moveRight(-speed);
    }

    renderer.render(scene, camera);
  }

  animate();

  // --- 6. リサイズ対応 ---
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // --- 7. 戻るボタン ---
  // ボタンクリック時はPointerLockが邪魔しないようにする
  document.getElementById('back').addEventListener('click', (e) => {
    e.stopPropagation(); // 親へのクリック伝播（＝PointerLock発動）を防ぐ
    window.location.href = '../index.html';
  });

</script>
</body>
</html>